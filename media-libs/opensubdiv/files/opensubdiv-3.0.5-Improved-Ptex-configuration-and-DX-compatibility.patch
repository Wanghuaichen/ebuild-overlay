diff -purN a/cmake/FindPTex.cmake b/cmake/FindPTex.cmake
--- a/cmake/FindPTex.cmake	2016-03-25 22:16:43.000000000 +0000
+++ b/cmake/FindPTex.cmake	2016-03-29 20:20:59.000000000 +0100
@@ -101,15 +101,21 @@ else ()
             DOC "The Ptex library")
 endif ()
 
-if (PTEX_INCLUDE_DIR AND EXISTS "${PTEX_INCLUDE_DIR}/Ptexture.h" )
+if (PTEX_INCLUDE_DIR AND EXISTS "${PTEX_INCLUDE_DIR}/PtexVersion.h")
+    set (PTEX_VERSION_FILE "${PTEX_INCLUDE_DIR}/PtexVersion.h")
+elseif (PTEX_INCLUDE_DIR AND EXISTS "${PTEX_INCLUDE_DIR}/Ptexture.h")    
+    set (PTEX_VERSION_FILE "${PTEX_INCLUDE_DIR}/Ptexture.h")
+endif()
 
-    file(STRINGS "${PTEX_INCLUDE_DIR}/Ptexture.h" TMP REGEX "^#define PtexAPIVersion.*$")
+if (PTEX_VERSION_FILE)
+
+    file(STRINGS "${PTEX_VERSION_FILE}" TMP REGEX "^#define PtexAPIVersion.*$")
     string(REGEX MATCHALL "[0-9]+" API ${TMP})
     
-    file(STRINGS "${PTEX_INCLUDE_DIR}/Ptexture.h" TMP REGEX "^#define PtexFileMajorVersion.*$")
+    file(STRINGS "${PTEX_VERSION_FILE}" TMP REGEX "^#define PtexFileMajorVersion.*$")
     string(REGEX MATCHALL "[0-9]+" MAJOR ${TMP})
 
-    file(STRINGS "${PTEX_INCLUDE_DIR}/Ptexture.h" TMP REGEX "^#define PtexFileMinorVersion.*$")
+    file(STRINGS "${PTEX_VERSION_FILE}" TMP REGEX "^#define PtexFileMinorVersion.*$")
     string(REGEX MATCHALL "[0-9]+" MINOR ${TMP})
 
     set(PTEX_VERSION ${API}.${MAJOR}.${MINOR})
diff -purN a/CMakeLists.txt b/CMakeLists.txt
--- a/CMakeLists.txt	2016-03-25 22:16:43.000000000 +0000
+++ b/CMakeLists.txt	2016-03-29 20:20:59.000000000 +0100
@@ -345,6 +345,7 @@ if(NOT NO_OPENGL AND NOT ANDROID AND NOT
 endif()
 if(NOT NO_PTEX)
    find_package(PTex 2.0)
+   find_package(Zlib 1.2)
 endif()
 if (OPENGL_FOUND AND NOT IOS)
     add_definitions(
@@ -520,6 +521,7 @@ endif()
 if(PTEX_FOUND)
     add_definitions(
         -DOPENSUBDIV_HAS_PTEX
+        -DPTEX_STATIC
     )
 else()
     if(NOT NO_PTEX)
diff -purN a/examples/CMakeLists.txt b/examples/CMakeLists.txt
--- a/examples/CMakeLists.txt	2016-03-25 22:16:43.000000000 +0000
+++ b/examples/CMakeLists.txt	2016-03-29 20:20:59.000000000 +0100
@@ -39,7 +39,7 @@ if (NOT NO_OPENGL)
             add_subdirectory(glPaintTest)
         endif()
 
-        if (PTEX_FOUND)
+        if (PTEX_FOUND AND ZLIB_FOUND)
             add_subdirectory(glPtexViewer)
         endif()
 
@@ -73,7 +73,7 @@ if (DXSDK_FOUND AND NOT NO_DX)
 
    add_subdirectory(dxViewer)
 
-   if (PTEX_FOUND)
+   if (PTEX_FOUND AND ZLIB_FOUND)
        add_subdirectory(dxPtexViewer)
    endif()
 
diff -purN a/examples/common/d3d11PtexMipmapTexture.cpp b/examples/common/d3d11PtexMipmapTexture.cpp
--- a/examples/common/d3d11PtexMipmapTexture.cpp	2016-03-25 22:16:43.000000000 +0000
+++ b/examples/common/d3d11PtexMipmapTexture.cpp	2016-03-29 20:20:59.000000000 +0100
@@ -26,14 +26,14 @@
 #include "ptexMipmapTextureLoader.h"
 #include <far/error.h>  // XXX: to be replaced
 
-#include <Ptexture.h>
 #include <D3D11.h>
 #include <cassert>
 
 D3D11PtexMipmapTexture::D3D11PtexMipmapTexture()
     : _width(0), _height(0), _depth(0),
       _layout(0), _texels(0),
-      _layoutSRV(0), _texelsSRV(0)
+      _layoutSRV(0), _texelsSRV(0),
+      _memoryUsage(0)
 {
 }
 
@@ -96,16 +96,25 @@ genTextureBuffer(ID3D11DeviceContext *de
 D3D11PtexMipmapTexture *
 D3D11PtexMipmapTexture::Create(ID3D11DeviceContext *deviceContext,
                                   PtexTexture * reader,
-                                  int maxLevels) {
+                                  int maxLevels,
+                                  size_t targetMemory) {
 
     D3D11PtexMipmapTexture * result = NULL;
 
     int maxNumPages = D3D10_REQ_TEXTURE2D_ARRAY_AXIS_DIMENSION;
 
     // Read the ptex data and pack the texels
-    PtexMipmapTextureLoader loader(reader, maxNumPages, maxLevels);
+    bool padAlpha = reader->numChannels()==3 and reader->dataType()!=Ptex::dt_float;
 
-    int numFaces = loader.GetNumFaces();
+    PtexMipmapTextureLoader loader(reader,
+                                   maxNumPages,
+                                   maxLevels,
+                                   targetMemory,
+                                   true, // seamlessMipmap
+                                   padAlpha);
+
+    int numChannels = reader->numChannels() + padAlpha,
+        numFaces = loader.GetNumFaces();
 
     ID3D11Buffer *layout = genTextureBuffer(deviceContext,
                                             numFaces * 6 * sizeof(short),
@@ -114,7 +123,6 @@ D3D11PtexMipmapTexture::Create(ID3D11Dev
 
     DXGI_FORMAT format = DXGI_FORMAT_UNKNOWN;
     int bpp = 0;
-    int numChannels = reader->numChannels();
     switch (reader->dataType()) {
         case Ptex::dt_uint16:
             switch (numChannels) {
@@ -138,7 +146,7 @@ D3D11PtexMipmapTexture::Create(ID3D11Dev
             switch (numChannels) {
                 case 1: format = DXGI_FORMAT_R16_FLOAT; break;
                 case 2: format = DXGI_FORMAT_R16G16_FLOAT; break;
-                case 3:assert(false); break;
+                case 3: assert(false); break;
                 case 4: format = DXGI_FORMAT_R16G16B16A16_FLOAT; break;
             }
             bpp = numChannels * 2;
@@ -218,6 +226,7 @@ D3D11PtexMipmapTexture::Create(ID3D11Dev
 
     result->_layoutSRV = layoutSRV;
     result->_texelsSRV = texelsSRV;
+    result->_memoryUsage = loader.GetMemoryUsage();
 
     return result;
 }
diff -purN a/examples/common/d3d11PtexMipmapTexture.h b/examples/common/d3d11PtexMipmapTexture.h
--- a/examples/common/d3d11PtexMipmapTexture.h	2016-03-25 22:16:43.000000000 +0000
+++ b/examples/common/d3d11PtexMipmapTexture.h	2016-03-29 20:20:59.000000000 +0100
@@ -27,7 +27,8 @@
 
 #include <osd/nonCopyable.h>
 
-class PtexTexture;
+#include <Ptexture.h>
+
 struct ID3D11Buffer;
 struct ID3D11Texture2D;
 struct ID3D11DeviceContext;
@@ -37,7 +38,8 @@ class D3D11PtexMipmapTexture : OpenSubdi
 public:
     static D3D11PtexMipmapTexture * Create(ID3D11DeviceContext *deviceContext,
                                               PtexTexture * reader,
-                                              int maxLevels=10);
+                                              int maxLevels=10,
+                                              size_t targetMemory=0);
 
     /// Returns GLSL shader snippet to fetch ptex
     static const char *GetShaderSource();
@@ -53,6 +55,9 @@ public:
 
     ID3D11ShaderResourceView **GetTexelsSRV() { return &_texelsSRV; }
 
+    /// Returns the amount of allocated memory (in byte)
+    size_t GetMemoryUsage() const { return _memoryUsage; }
+
     ~D3D11PtexMipmapTexture();
 
 private:
@@ -68,6 +73,8 @@ private:
     ID3D11Texture2D *_texels;  // texel data
     ID3D11ShaderResourceView *_layoutSRV;
     ID3D11ShaderResourceView *_texelsSRV;
+
+    size_t _memoryUsage;  // total amount of memory used (estimate)
 };
 
 #endif  // OPENSUBDIV_EXAMPLES_D3D11_PTEX_TEXTURE_H
diff -purN a/examples/common/glPtexMipmapTexture.cpp b/examples/common/glPtexMipmapTexture.cpp
--- a/examples/common/glPtexMipmapTexture.cpp	2016-03-25 22:16:43.000000000 +0000
+++ b/examples/common/glPtexMipmapTexture.cpp	2016-03-29 20:20:59.000000000 +0100
@@ -27,8 +27,6 @@
 
 #include <osd/opengl.h>
 
-#include <Ptexture.h>
-
 GLPtexMipmapTexture::GLPtexMipmapTexture()
     : _width(0), _height(0), _depth(0), _layout(0), _texels(0), _memoryUsage(0)
 {
diff -purN a/examples/common/glPtexMipmapTexture.h b/examples/common/glPtexMipmapTexture.h
--- a/examples/common/glPtexMipmapTexture.h	2016-03-25 22:16:43.000000000 +0000
+++ b/examples/common/glPtexMipmapTexture.h	2016-03-29 20:20:59.000000000 +0100
@@ -28,10 +28,9 @@
 #include <osd/nonCopyable.h>
 #include <osd/opengl.h>
 
+#include <Ptexture.h>
 #include <stdlib.h>
 
-class PtexTexture;
-
 class GLPtexMipmapTexture : OpenSubdiv::Osd::NonCopyable<GLPtexMipmapTexture> {
 public:
     static GLPtexMipmapTexture * Create(PtexTexture * reader,
diff -purN a/examples/common/ptexMipmapTextureLoader.cpp b/examples/common/ptexMipmapTextureLoader.cpp
--- a/examples/common/ptexMipmapTextureLoader.cpp	2016-03-25 22:16:43.000000000 +0000
+++ b/examples/common/ptexMipmapTextureLoader.cpp	2016-03-29 20:20:59.000000000 +0100
@@ -24,7 +24,6 @@
 
 #include "ptexMipmapTextureLoader.h"
 
-#include <Ptexture.h>
 #include <vector>
 #include <list>
 #include <algorithm>
@@ -447,10 +446,11 @@ PtexMipmapTextureLoader::PtexMipmapTextu
                                                        int maxNumPages,
                                                        int maxLevels,
                                                        size_t targetMemory,
-                                                       bool seamlessMipmap) :
+                                                       bool seamlessMipmap,
+                                                       bool padAlpha) :
     _ptex(ptex), _maxLevels(maxLevels), _bpp(0),
-    _pageWidth(0), _pageHeight(0), _texelBuffer(NULL), _layoutBuffer(NULL),
-    _memoryUsage(0)
+    _pageWidth(0), _pageHeight(0), _padAlpha(padAlpha),
+    _texelBuffer(NULL), _layoutBuffer(NULL), _memoryUsage(0)
 {
     // byte per pixel
     _bpp = ptex->numChannels() * Ptex::DataSize(ptex->dataType());
@@ -474,6 +474,10 @@ PtexMipmapTextureLoader::PtexMipmapTextu
 
     optimizePacking(maxNumPages, targetMemory);
     generateBuffers();
+    
+    if (padAlpha) {
+        addAlphaChannel();
+    }
 }
 
 PtexMipmapTextureLoader::~PtexMipmapTextureLoader()
@@ -485,6 +489,48 @@ PtexMipmapTextureLoader::~PtexMipmapText
     delete _layoutBuffer;
 }
 
+// add alpha channel to texelbuffer :
+//   assumes the texel buffer has been generated and apply a raw copy
+//   into a larger buffer with an alpha channel padded in
+// note : this is not a particularly elegant solution...
+void
+PtexMipmapTextureLoader::addAlphaChannel() {
+
+    assert(_ptex);
+
+    // allocate new larger texel buffer
+    int bpc = Ptex::DataSize(_ptex->dataType()),
+        srcStride = _ptex->numChannels() * bpc,
+        dstStride = srcStride + bpc;
+
+    size_t numTexels = _pageWidth * _pageHeight * _pages.size(),
+           memoryUsed = dstStride * numTexels;
+
+    unsigned char * texBuffer = new unsigned char[memoryUsed];
+
+    // loop over every texel & copy + pad
+    unsigned char const * src = _texelBuffer;
+    unsigned char * dest = texBuffer;
+
+    for (int i=0; i<numTexels; ++i, src+=srcStride, dest+=dstStride) {
+        memcpy(dest, src, srcStride);
+
+        /// set alpha to 1
+        switch (_ptex->dataType()) {
+            case Ptex::dt_uint8  : *(uint8_t *)(dest+srcStride)= 0xFF; break;
+            case Ptex::dt_uint16 : *(uint16_t *)(dest+srcStride) = 0xFFFF; break;
+            case Ptex::dt_half   : *(uint16_t *)(dest+srcStride) = 0x3C00; break;
+            case Ptex::dt_float  : *(float *)(dest+srcStride) = 1.0f; break;
+        }
+    }
+
+    // remove old buffer & adjust class members
+    delete [] _texelBuffer;
+    _texelBuffer = texBuffer;
+    _memoryUsage = memoryUsed;
+    _bpp = dstStride;
+}
+
 // resample border texels for guttering
 //
 int
diff -purN a/examples/common/ptexMipmapTextureLoader.h b/examples/common/ptexMipmapTextureLoader.h
--- a/examples/common/ptexMipmapTextureLoader.h	2016-03-25 22:16:43.000000000 +0000
+++ b/examples/common/ptexMipmapTextureLoader.h	2016-03-29 20:20:59.000000000 +0100
@@ -25,11 +25,11 @@
 #ifndef OPENSUBDIV_EXAMPLES_PTEX_MIPMAP_TEXTURE_LOADER_H
 #define OPENSUBDIV_EXAMPLES_PTEX_MIPMAP_TEXTURE_LOADER_H
 
+#include <Ptexture.h>
 #include <stdlib.h>
 #include <stdint.h>
 #include <vector>
 
-class PtexTexture;
 
 class PtexMipmapTextureLoader {
 public:
@@ -37,7 +37,8 @@ public:
                                int maxNumPages,
                                int maxLevels = -1,
                                size_t targetMemory = 0,
-                               bool seamlessMipmap = true);
+                               bool seamlessMipmap = true,
+                               bool padAlpha = false);
 
     ~PtexMipmapTextureLoader();
 
@@ -136,6 +137,7 @@ private:
     int  resampleBorder(int face, int edgeId, unsigned char *result,
                         int dstLength, int bpp,
                         float srcStart = 0.0f, float srcEnd = 1.0f);
+    void addAlphaChannel();
 
     std::vector<Block> _blocks;
     std::vector<Page *> _pages;
@@ -145,6 +147,8 @@ private:
     int _bpp;
     int _pageWidth, _pageHeight;
 
+    bool _padAlpha;
+
     unsigned char *_texelBuffer;
     unsigned char *_layoutBuffer;
 
diff -purN a/examples/dxPtexViewer/CMakeLists.txt b/examples/dxPtexViewer/CMakeLists.txt
--- a/examples/dxPtexViewer/CMakeLists.txt	2016-03-25 22:16:43.000000000 +0000
+++ b/examples/dxPtexViewer/CMakeLists.txt	2016-03-29 20:20:59.000000000 +0100
@@ -26,12 +26,14 @@
 
 set(SHADER_FILES
      shader.hlsl
+     skyshader.hlsl
 )
 
 set(PLATFORM_LIBRARIES
     "${OSD_LINK_TARGET}"
     "${DXSDK_LIBRARIES}"
     "${PTEX_LIBRARY}"
+    "${ZLIB_LIBRARY}"
 )
 
 include_directories(
@@ -55,6 +57,7 @@ endif()
 
 set(SOURCE_FILES
     dxPtexViewer.cpp
+    sky.cpp
 )
 
 _stringify("${SHADER_FILES}" INC_FILES)
diff -purN a/examples/dxPtexViewer/dxPtexViewer.cpp b/examples/dxPtexViewer/dxPtexViewer.cpp
--- a/examples/dxPtexViewer/dxPtexViewer.cpp	2016-03-25 22:16:43.000000000 +0000
+++ b/examples/dxPtexViewer/dxPtexViewer.cpp	2016-03-29 20:20:59.000000000 +0100
@@ -58,6 +58,8 @@
 #include <osd/d3d11Mesh.h>
 OpenSubdiv::Osd::D3D11MeshInterface *g_mesh;
 
+#include "./sky.h"
+
 #include "Ptexture.h"
 #include "PtexUtils.h"
 
@@ -67,6 +69,7 @@ OpenSubdiv::Osd::D3D11MeshInterface *g_m
 #include "../common/d3d11Hud.h"
 #include "../common/d3d11PtexMipmapTexture.h"
 #include "../common/d3d11ShaderCache.h"
+#include "../common/hdr_reader.h"
 
 #include <osd/hlslPatchShaderSource.h>
 static const char *g_shaderSource =
@@ -205,11 +208,16 @@ float g_animTime = 0;
 std::vector<float> g_positions,
                    g_normals;
 
+std::vector<std::vector<float> > g_animPositions;
+
+Sky * g_sky=0;
+
 D3D11PtexMipmapTexture * g_osdPTexImage = 0;
 D3D11PtexMipmapTexture * g_osdPTexDisplacement = 0;
 D3D11PtexMipmapTexture * g_osdPTexOcclusion = 0;
 D3D11PtexMipmapTexture * g_osdPTexSpecular = 0;
 const char * g_ptexColorFilename;
+size_t g_ptexMemoryUsage = 0;
 
 ID3D11Device * g_pd3dDevice = NULL;
 ID3D11DeviceContext * g_pd3dDeviceContext = NULL;
@@ -217,18 +225,64 @@ IDXGISwapChain * g_pSwapChain = NULL;
 ID3D11RenderTargetView * g_pSwapChainRTV = NULL;
 
 ID3D11RasterizerState* g_pRasterizerState = NULL;
-ID3D11InputLayout* g_pInputLayout = NULL;
-ID3D11DepthStencilState* g_pDepthStencilState = NULL;
+ID3D11InputLayout * g_pInputLayout = NULL;
+ID3D11DepthStencilState * g_pDepthStencilState = NULL;
 ID3D11Texture2D * g_pDepthStencilBuffer = NULL;
-ID3D11Buffer* g_pcbPerFrame = NULL;
-ID3D11Buffer* g_pcbTessellation = NULL;
-ID3D11Buffer* g_pcbLighting = NULL;
-ID3D11Buffer* g_pcbConfig = NULL;
-ID3D11DepthStencilView* g_pDepthStencilView = NULL;
+ID3D11Buffer * g_pcbPerFrame = NULL;
+ID3D11Buffer * g_pcbTessellation = NULL;
+ID3D11Buffer * g_pcbLighting = NULL;
+ID3D11Buffer * g_pcbConfig = NULL;
+ID3D11DepthStencilView * g_pDepthStencilView = NULL;
+
+ID3D11Texture2D * g_diffuseEnvironmentMap = NULL;
+ID3D11ShaderResourceView * g_diffuseEnvironmentSRV = NULL;
+
+ID3D11Texture2D * g_specularEnvironmentMap = NULL;
+ID3D11ShaderResourceView * g_specularEnvironmentSRV = NULL;
+
+ID3D11SamplerState * g_iblSampler = NULL;
+
+ID3D11Query * g_pipelineStatsQuery = NULL;
 
 bool g_bDone = false;
 
 //------------------------------------------------------------------------------
+
+static ID3D11Texture2D *
+createHDRTexture(ID3D11Device * device, char const * hdrFile) {
+
+    HdrInfo info;
+    unsigned char * image = loadHdr(hdrFile, &info, /*convertToFloat=*/true);
+    if (image) {
+
+        D3D11_TEXTURE2D_DESC texDesc;
+        ZeroMemory(&texDesc, sizeof(texDesc));
+        texDesc.Width = info.width;
+        texDesc.Height = info.height;
+        texDesc.MipLevels = 1;
+        texDesc.ArraySize = 1;
+        texDesc.Format = DXGI_FORMAT_R32G32B32A32_FLOAT;
+        texDesc.SampleDesc.Count = 1;
+        texDesc.SampleDesc.Quality = 0;
+        texDesc.Usage = D3D11_USAGE_DEFAULT;
+        texDesc.BindFlags =  D3D11_BIND_UNORDERED_ACCESS | D3D11_BIND_SHADER_RESOURCE;
+        texDesc.CPUAccessFlags = 0;
+        texDesc.MiscFlags = 0;
+
+        D3D11_SUBRESOURCE_DATA subData;
+        subData.pSysMem = (void *)image;
+        subData.SysMemPitch = info.width * 4 * sizeof(float);
+
+        ID3D11Texture2D * texture=0;
+        device->CreateTexture2D(&texDesc, &subData, &texture);
+
+        free(image);
+        return texture;
+    }
+    return 0;
+}
+
+//------------------------------------------------------------------------------
 static void
 calcNormals(OpenSubdiv::Far::TopologyRefiner * refiner,
     std::vector<float> const & pos, std::vector<float> & result ) {
@@ -269,28 +323,61 @@ updateGeom() {
 
     int nverts = (int)g_positions.size() / 3;
 
-    std::vector<float> vertex;
-    vertex.reserve(nverts*6);
+    if (g_moveScale and g_adaptive and not g_animPositions.empty()) {
 
-    const float *p = &g_positions[0];
-    const float *n = &g_normals[0];
+        // baked animation only works with adaptive for now
+        // (since non-adaptive requires normals)
+        int nkeys = (int)g_animPositions.size();
+        const float fps = 24.0f;
+
+        float p = fmodf(g_animTime * fps, (float)nkeys);
+        int key = (int)p;
+        float b = p - key;
+
+        std::vector<float> vertex;
+        vertex.reserve(nverts*3);
+        for (int vert = 0; vert<nverts; ++vert) {
 
-    for (int i = 0; i < nverts; ++i) {
-        float move = g_size*0.005f*cosf(p[0]*100/g_size+g_frame*0.01f);
-        vertex.push_back(p[0]);
-        vertex.push_back(p[1]+g_moveScale*move);
-        vertex.push_back(p[2]);
-        p += 3;
-//        if (g_adaptive == false)
-        {
-            vertex.push_back(n[0]);
-            vertex.push_back(n[1]);
-            vertex.push_back(n[2]);
-            n += 3;
+            float const * p0 = &g_animPositions[key][vert*3],
+                        * p1 = &g_animPositions[(key+1)%nkeys][vert*3];
+
+            for (int i=0; i<3; ++i, ++p0, ++p1) {
+                vertex.push_back(*p0*(1.0f-b) + *p1*b);
+            }
+
+            // adaptive patches don't need normals, but we do not have an
+            // an easy shader variant with positions only
+            vertex.push_back(0.0f);
+            vertex.push_back(0.0f);
+            vertex.push_back(0.0f);
         }
-    }
 
-    g_mesh->UpdateVertexBuffer(&vertex[0], 0, nverts);
+        g_mesh->UpdateVertexBuffer(&vertex[0], 0, nverts);
+
+    } else {
+        std::vector<float> vertex;
+        vertex.reserve(nverts*6);
+
+        const float *p = &g_positions[0];
+        const float *n = &g_normals[0];
+
+        for (int i = 0; i < nverts; ++i) {
+            float move = g_size*0.005f*cosf(p[0]*100/g_size+g_frame*0.01f);
+            vertex.push_back(p[0]);
+            vertex.push_back(p[1]+g_moveScale*move);
+            vertex.push_back(p[2]);
+            p += 3;
+    //        if (g_adaptive == false)
+            {
+                vertex.push_back(n[0]);
+                vertex.push_back(n[1]);
+                vertex.push_back(n[2]);
+                n += 3;
+            }
+        }
+
+        g_mesh->UpdateVertexBuffer(&vertex[0], 0, nverts);
+    }
 
     Stopwatch s;
     s.Start();
@@ -371,6 +458,7 @@ createPTexGeo(PtexTexture * r) {
         }
     }
 
+    g_size=0.0f;
     for (int j = 0; j < 3; ++j) {
         g_center[j] = (min[j] + max[j]) * 0.5f;
         g_size += (max[j]-min[j])*(max[j]-min[j]);
@@ -644,7 +732,7 @@ ShaderCache g_shaderCache;
 
 //------------------------------------------------------------------------------
 D3D11PtexMipmapTexture *
-createPtex(const char *filename) {
+createPtex(const char *filename, int memLimit) {
 
     Ptex::String ptexError;
     printf("Loading ptex : %s\n", filename);
@@ -663,8 +751,11 @@ createPtex(const char *filename) {
         printf("Error in reading %s\n", filename);
         exit(1);
     }
+
+    size_t targetMemory = memLimit * 1024 * 1024; // MB
+
     D3D11PtexMipmapTexture *osdPtex = D3D11PtexMipmapTexture::Create(
-        g_pd3dDeviceContext, ptex, g_maxMipmapLevels);
+        g_pd3dDeviceContext, ptex, g_maxMipmapLevels, targetMemory);
 
     ptex->release();
 
@@ -835,6 +926,7 @@ bindProgram(Effect effect, OpenSubdiv::O
             float ModelViewMatrix[16];
             float ProjectionMatrix[16];
             float ModelViewProjectionMatrix[16];
+            float ModelViewInverseMatrix[16];
         };
 
         if (! g_pcbPerFrame) {
@@ -861,9 +953,12 @@ bindProgram(Effect effect, OpenSubdiv::O
         translate(pData->ModelViewMatrix, -g_center[0], -g_center[1], -g_center[2]);
 
         identity(pData->ProjectionMatrix);
-        perspective(pData->ProjectionMatrix, 45.0, aspect, 0.01f, 500.0);
-        multMatrix(pData->ModelViewProjectionMatrix, pData->ModelViewMatrix, pData->ProjectionMatrix);
-
+        perspective(pData->ProjectionMatrix, 45.0, aspect, g_size*0.001f, g_size+g_dolly);
+        multMatrix(pData->ModelViewProjectionMatrix,
+                   pData->ModelViewMatrix,
+                   pData->ProjectionMatrix);
+        inverseMatrix(pData->ModelViewInverseMatrix,
+                      pData->ModelViewMatrix);
         g_pd3dDeviceContext->Unmap( g_pcbPerFrame, 0 );
     }
 
@@ -971,6 +1066,19 @@ bindProgram(Effect effect, OpenSubdiv::O
         g_pd3dDeviceContext->PSSetShaderResources(10, 1, g_osdPTexSpecular->GetTexelsSRV());
         g_pd3dDeviceContext->PSSetShaderResources(11, 1, g_osdPTexSpecular->GetLayoutSRV());
     }
+
+    if (g_ibl) {
+        if (g_diffuseEnvironmentMap) {
+            g_pd3dDeviceContext->PSSetShaderResources(12, 1, &g_diffuseEnvironmentSRV);
+
+        }
+        if (g_specularEnvironmentMap) {
+            g_pd3dDeviceContext->PSSetShaderResources(13, 1, &g_specularEnvironmentSRV);
+
+        }
+        assert(g_iblSampler);
+        g_pd3dDeviceContext->PSSetSamplers(0, 1, &g_iblSampler);
+    }
 }
 
 //------------------------------------------------------------------------------
@@ -1061,27 +1169,100 @@ drawModel() {
 static void
 display() {
 
+    Stopwatch s;
+    s.Start();
+
     float color[4] = {0.006f, 0.006f, 0.006f, 1.0f};
     g_pd3dDeviceContext->ClearRenderTargetView(g_pSwapChainRTV, color);
 
     // Clear the depth buffer.
     g_pd3dDeviceContext->ClearDepthStencilView(g_pDepthStencilView, D3D11_CLEAR_DEPTH, 1.0f, 0);
 
+    if (g_ibl && g_sky) {
+
+        float modelView[16], projection[16], mvp[16];
+        double aspect = g_width/(double)g_height;
+
+        identity(modelView);
+        rotate(modelView, g_rotate[1], 1, 0, 0);
+        rotate(modelView, g_rotate[0], 0, 1, 0);
+        perspective(projection, 45.0f, (float)aspect, g_size*0.001f, g_size+g_dolly);
+        multMatrix(mvp, modelView, projection);
+
+        g_sky->Draw(g_pd3dDeviceContext, mvp);
+    }
+
+// this query can be slow : comment out #define to turn off
+#define PIPELINE_STATISTICS
+#ifdef PIPELINE_STATISTICS
+    g_pd3dDeviceContext->Begin(g_pipelineStatsQuery);
+#endif // PIPELINE_STATISTICS
+
     g_pd3dDeviceContext->OMSetDepthStencilState(g_pDepthStencilState, 1);
     g_pd3dDeviceContext->RSSetState(g_pRasterizerState);
 
     drawModel();
 
+#ifdef PIPELINE_STATISTICS
+    g_pd3dDeviceContext->End(g_pipelineStatsQuery);
+#endif // PIPELINE_STATISTICS
+
+    s.Stop();
+    float drawCpuTime = float(s.GetElapsed() * 1000.0f);
+
+    int timeElapsed = 0;
+    // XXXX TODO GPU cycles elapsed query
+    float drawGpuTime = timeElapsed / 1000.0f / 1000.0f;
+
+    UINT64 numPrimsGenerated = 0;
+#ifdef PIPELINE_STATISTICS
+    D3D11_QUERY_DATA_PIPELINE_STATISTICS pipelineStats;
+    ZeroMemory(&pipelineStats, sizeof(pipelineStats));
+    while (S_OK != g_pd3dDeviceContext->GetData(g_pipelineStatsQuery, &pipelineStats, g_pipelineStatsQuery->GetDataSize(), 0));
+    numPrimsGenerated = pipelineStats.GSPrimitives;
+#endif // PIPELINE_STATISTICS
 
-    if (g_hud->IsVisible()) {
         g_fpsTimer.Stop();
-        double fps = 1.0/g_fpsTimer.GetElapsed();
+    float elapsed = (float)g_fpsTimer.GetElapsed();
+    if (not g_freeze)
+        g_animTime += elapsed;
         g_fpsTimer.Start();
 
-        g_hud->DrawString(10, -100, "# of Vertices = %d", g_mesh->GetNumVertices());
-        g_hud->DrawString(10, -60, "GPU TIME = %.3f ms", g_gpuTime);
-        g_hud->DrawString(10, -40, "CPU TIME = %.3f ms", g_cpuTime);
-        g_hud->DrawString(10, -20, "FPS = %3.1f", fps);
+
+    if (g_hud->IsVisible()) {
+
+        double fps = 1.0/elapsed;
+
+        // Avereage fps over a defined number of time samples for
+        // easier reading in the HUD
+        g_fpsTimeSamples[g_currentFpsTimeSample++] = float(fps);
+        if (g_currentFpsTimeSample >= NUM_FPS_TIME_SAMPLES)
+            g_currentFpsTimeSample = 0;
+        double averageFps = 0;
+        for (int i = 0; i < NUM_FPS_TIME_SAMPLES; ++i) {
+            averageFps += g_fpsTimeSamples[i]/(float)NUM_FPS_TIME_SAMPLES;
+        }
+
+        g_hud->DrawString(10, -220, "Ptex memory use : %.1f mb", g_ptexMemoryUsage/1024.0/1024.0);
+        g_hud->DrawString(10, -180, "Tess level (+/-): %d", g_tessLevel);
+#ifdef PIPELINE_STATISTICS
+        if (numPrimsGenerated > 1000000) {
+            g_hud->DrawString(10, -160, "Primitives      : %3.1f million",
+                             (float)numPrimsGenerated/1000000.0);
+        } else if (numPrimsGenerated > 1000) {
+            g_hud->DrawString(10, -160, "Primitives      : %3.1f thousand",
+                             (float)numPrimsGenerated/1000.0);
+        } else {
+            g_hud->DrawString(10, -160, "Primitives      : %d", numPrimsGenerated);
+        }
+#endif // PIPELINE_STATISTICS
+        g_hud->DrawString(10, -140, "Vertices        : %d", g_mesh->GetNumVertices());
+        g_hud->DrawString(10, -120, "Scheme          : %s", g_scheme == 0 ? "CATMARK" : "LOOP");
+        g_hud->DrawString(10, -100, "GPU Kernel      : %.3f ms", g_gpuTime);
+        g_hud->DrawString(10, -80,  "CPU Kernel      : %.3f ms", g_cpuTime);
+        g_hud->DrawString(10, -60,  "GPU Draw        : %.3f ms", drawGpuTime);
+        g_hud->DrawString(10, -40,  "CPU Draw        : %.3f ms", drawCpuTime);
+        g_hud->DrawString(10, -20,  "FPS             : %3.1f", fps);
     }
 
     g_hud->Flush();
@@ -1293,50 +1474,77 @@ initHUD() {
     g_hud = new D3D11hud(g_pd3dDeviceContext);
     g_hud->Init(g_width, g_height);
 
-    g_hud->AddRadioButton(0, "CPU (K)", true, 10, 10, callbackKernel, kCPU, 'K');
+
+    if (g_osdPTexOcclusion != NULL) {
+        g_hud->AddCheckBox("Ambient Occlusion (A)", g_occlusion,
+                          -200, 570, callbackCheckBox, HUD_CB_DISPLAY_OCCLUSION, 'a');
+    }
+    if (g_osdPTexSpecular != NULL)
+        g_hud->AddCheckBox("Specular (S)", g_specular,
+                          -200, 590, callbackCheckBox, HUD_CB_DISPLAY_SPECULAR, 's');
+
+    if (g_diffuseEnvironmentMap || g_diffuseEnvironmentMap) {
+        g_hud->AddCheckBox("IBL (I)", g_ibl,
+                          -200, 610, callbackCheckBox, HUD_CB_IBL, 'i');
+    }
+
+    g_hud->AddCheckBox("Animate vertices (M)", g_moveScale != 0.0,
+                      10, 30, callbackCheckBox, HUD_CB_ANIMATE_VERTICES, 'm');
+    g_hud->AddCheckBox("Screen space LOD (V)",  g_screenSpaceTess,
+                      10, 50, callbackCheckBox, HUD_CB_VIEW_LOD, 'v');
+    g_hud->AddCheckBox("Fractional spacing (T)",  g_fractionalSpacing,
+                      10, 70, callbackCheckBox, HUD_CB_FRACTIONAL_SPACING, 't');
+    g_hud->AddCheckBox("Frustum Patch Culling (B)",  g_patchCull,
+                      10, 90, callbackCheckBox, HUD_CB_PATCH_CULL, 'b');
+    g_hud->AddCheckBox("Bloom (Y)", g_bloom,
+                      10, 110, callbackCheckBox, HUD_CB_BLOOM, 'y');
+    g_hud->AddCheckBox("Freeze (spc)", g_freeze,
+                      10, 130, callbackCheckBox, HUD_CB_FREEZE, ' ');
+
+    g_hud->AddRadioButton(HUD_RB_SCHEME, "CATMARK", true, 10, 190, callbackScheme, 0);
+    g_hud->AddRadioButton(HUD_RB_SCHEME, "BILINEAR", false, 10, 210, callbackScheme, 1);
+
+    g_hud->AddCheckBox("Adaptive (`)", g_adaptive,
+                       10, 300, callbackCheckBox, HUD_CB_ADAPTIVE, '`');
+
+    for (int i = 1; i < 8; ++i) {
+        char level[16];
+        sprintf(level, "Lv. %d", i);
+        g_hud->AddRadioButton(HUD_RB_LEVEL, level, i == g_level,
+                              10, 320+i*20, callbackLevel, i, '0'+i);
+    }
+
+    int compute_pulldown = g_hud->AddPullDown("Compute (K)", 475, 10, 300, callbackKernel, 'k');
+    g_hud->AddPullDownButton(compute_pulldown, "CPU (K)", kCPU);
 #ifdef OPENSUBDIV_HAS_OPENMP
-    g_hud->AddRadioButton(0, "OPENMP", false, 10, 30, callbackKernel, kOPENMP, 'K');
+    g_hud->AddPullDownButton(compute_pulldown, "OPENMP", kOPENMP);
 #endif
 #ifdef OPENSUBDIV_HAS_TBB
-    g_hud->AddRadioButton(0, "TBB", false, 10, 50, callbackKernel, kTBB, 'K');
+    g_hud->AddPullDownButton(compute_pulldown, "TBB", kTBB);
 #endif
 #ifdef OPENSUBDIV_HAS_CUDA
-    g_hud->AddRadioButton(0, "CUDA", false, 10, 70, callbackKernel, kCUDA, 'K');
+    g_hud->AddPullDownButton(compute_pulldown, "CUDA", kCUDA);
 #endif
 #ifdef OPENSUBDIV_HAS_OPENCL
     if (CLDeviceContext::HAS_CL_VERSION_1_1()) {
-        g_hud->AddRadioButton(0, "OPENCL", false, 10, 90, callbackKernel, kCL, 'K');
+        g_hud->AddPullDownButton(compute_pulldown, "OPENCL", kCL);
     }
 #endif
-    g_hud->AddRadioButton(0, "DirectCompute", false, 10, 110, callbackKernel, kDirectCompute, 'K');
-
-    g_hud->AddCheckBox("Adaptive (`)", g_adaptive,
-                       10, 150, callbackCheckBox, HUD_CB_ADAPTIVE, '`');
-
-    g_hud->AddRadioButton(HUD_RB_SCHEME, "CATMARK", true, 10, 190, callbackScheme, 0, 's');
-    g_hud->AddRadioButton(HUD_RB_SCHEME, "BILINEAR", false, 10, 210, callbackScheme, 1, 's');
-
-    for (int i = 1; i < 8; ++i) {
-        char level[16];
-        sprintf(level, "Lv. %d", i);
-        g_hud->AddRadioButton(HUD_RB_LEVEL, level, i == g_level,
-                              10, 220+i*20, callbackLevel, i, '0'+i);
-    }
+    g_hud->AddPullDownButton(compute_pulldown, "DirectCompute", kDirectCompute);
 
-    g_hud->AddRadioButton(HUD_RB_WIRE, "Wire (W)",       (g_wire == DISPLAY_WIRE),
-                         100, 10, callbackWireframe, 0, 'w');
-    g_hud->AddRadioButton(HUD_RB_WIRE, "Shaded",         (g_wire == DISPLAY_SHADED),
-                         100, 30, callbackWireframe, 1, 'w');
-    g_hud->AddRadioButton(HUD_RB_WIRE, "Wire on Shaded", (g_wire == DISPLAY_WIRE_ON_SHADED),
-                         100, 50, callbackWireframe, 2, 'w');
+    int shading_pulldown = g_hud->AddPullDown("Shading (W)", 250, 10, 250, callbackWireframe, 'w');
+    g_hud->AddPullDownButton(shading_pulldown, "Wire", DISPLAY_WIRE, g_wire==DISPLAY_WIRE);
+    g_hud->AddPullDownButton(shading_pulldown, "Shaded", DISPLAY_SHADED, g_wire==DISPLAY_SHADED);
+    g_hud->AddPullDownButton(shading_pulldown, "Wire+Shaded", DISPLAY_WIRE_ON_SHADED, g_wire==DISPLAY_WIRE_ON_SHADED);
 
     g_hud->AddLabel("Color (C)", -200, 10);
     g_hud->AddRadioButton(HUD_RB_COLOR, "None", (g_color == COLOR_NONE),
                          -200, 30, callbackColor, COLOR_NONE, 'c');
     g_hud->AddRadioButton(HUD_RB_COLOR, "Ptex Nearest", (g_color == COLOR_PTEX_NEAREST),
                          -200, 50, callbackColor, COLOR_PTEX_NEAREST, 'c');
-    g_hud->AddRadioButton(HUD_RB_COLOR, "Ptex HW bilinear", (g_color == COLOR_PTEX_HW_BILINEAR),
-                         -200, 70, callbackColor, COLOR_PTEX_HW_BILINEAR, 'c');
+    // Commented out : we need to add a texture sampler state to make this work
+    //g_hud->AddRadioButton(HUD_RB_COLOR, "Ptex HW bilinear", (g_color == COLOR_PTEX_HW_BILINEAR),
+    //                     -200, 70, callbackColor, COLOR_PTEX_HW_BILINEAR, 'c');
     g_hud->AddRadioButton(HUD_RB_COLOR, "Ptex bilinear", (g_color == COLOR_PTEX_BILINEAR),
                          -200, 90, callbackColor, COLOR_PTEX_BILINEAR, 'c');
     g_hud->AddRadioButton(HUD_RB_COLOR, "Ptex biquadratic", (g_color == COLOR_PTEX_BIQUADRATIC),
@@ -1353,9 +1561,10 @@ initHUD() {
         g_hud->AddRadioButton(HUD_RB_DISPLACEMENT, "None",
                              (g_displacement == DISPLACEMENT_NONE),
                              -200, 220, callbackDisplacement, DISPLACEMENT_NONE, 'd');
-        g_hud->AddRadioButton(HUD_RB_DISPLACEMENT, "HW bilinear",
-                             (g_displacement == DISPLACEMENT_HW_BILINEAR),
-                             -200, 240, callbackDisplacement, DISPLACEMENT_HW_BILINEAR, 'd');
+        // Commented out : we need to add a texture sampler state to make this work
+        //g_hud->AddRadioButton(HUD_RB_DISPLACEMENT, "HW bilinear",
+        //                     (g_displacement == DISPLACEMENT_HW_BILINEAR),
+        //                     -200, 240, callbackDisplacement, DISPLACEMENT_HW_BILINEAR, 'd');
         g_hud->AddRadioButton(HUD_RB_DISPLACEMENT, "Bilinear",
                              (g_displacement == DISPLACEMENT_BILINEAR),
                              -200, 260, callbackDisplacement, DISPLACEMENT_BILINEAR, 'd');
@@ -1391,24 +1600,6 @@ initHUD() {
     g_hud->AddCheckBox("Seamless Mipmap", g_seamless,
                        -200, 530, callbackCheckBox, HUD_CB_SEAMLESS_MIPMAP, 'j');
 
-    if (g_osdPTexOcclusion != NULL) {
-        g_hud->AddCheckBox("Ambient Occlusion (A)", g_occlusion,
-                          250, 10, callbackCheckBox, HUD_CB_DISPLAY_OCCLUSION, 'a');
-    }
-    if (g_osdPTexSpecular != NULL)
-        g_hud->AddCheckBox("Specular (S)", g_specular,
-                          250, 30, callbackCheckBox, HUD_CB_DISPLAY_SPECULAR, 's');
-
-    g_hud->AddCheckBox("Animate vertices (M)", g_moveScale != 0.0,
-                      450, 10, callbackCheckBox, HUD_CB_ANIMATE_VERTICES, 'm');
-    g_hud->AddCheckBox("Screen space LOD (V)",  g_screenSpaceTess,
-                      450, 30, callbackCheckBox, HUD_CB_VIEW_LOD, 'v');
-    g_hud->AddCheckBox("Fractional spacing (T)",  g_fractionalSpacing,
-                      450, 50, callbackCheckBox, HUD_CB_FRACTIONAL_SPACING, 't');
-    g_hud->AddCheckBox("Frustum Patch Culling (B)",  g_patchCull,
-                      450, 70, callbackCheckBox, HUD_CB_PATCH_CULL, 'b');
-    g_hud->AddCheckBox("Freeze (spc)", g_freeze,
-                      450, 90, callbackCheckBox, HUD_CB_FREEZE, ' ');
 }
 
 //------------------------------------------------------------------------------
@@ -1423,9 +1614,18 @@ initD3D11(HWND hWnd) {
 
     UINT numDriverTypes = ARRAYSIZE(driverTypes);
 
+    int width = g_width,
+        height = g_height;
+    if (g_fullscreen) {
+        HWND const desktop = GetDesktopWindow();
+        RECT rect;
+        GetWindowRect(desktop, &rect);
+        width = (int)rect.right;
+        height = (int)rect.bottom;
+    }
     DXGI_SWAP_CHAIN_DESC hDXGISwapChainDesc;
-    hDXGISwapChainDesc.BufferDesc.Width = g_width;
-    hDXGISwapChainDesc.BufferDesc.Height = g_height;
+    hDXGISwapChainDesc.BufferDesc.Width = width;
+    hDXGISwapChainDesc.BufferDesc.Height = height;
     hDXGISwapChainDesc.BufferDesc.RefreshRate.Numerator  = 0;
     hDXGISwapChainDesc.BufferDesc.RefreshRate.Denominator = 1;
     hDXGISwapChainDesc.BufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
@@ -1436,7 +1636,7 @@ initD3D11(HWND hWnd) {
     hDXGISwapChainDesc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;
     hDXGISwapChainDesc.BufferCount = 1;
     hDXGISwapChainDesc.OutputWindow = hWnd;
-    hDXGISwapChainDesc.Windowed = TRUE;
+    hDXGISwapChainDesc.Windowed = !g_fullscreen;
     hDXGISwapChainDesc.SwapEffect = DXGI_SWAP_EFFECT_DISCARD;
     hDXGISwapChainDesc.Flags = DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;
 
@@ -1447,9 +1647,9 @@ initD3D11(HWND hWnd) {
     for(UINT driverTypeIndex=0; driverTypeIndex < numDriverTypes; driverTypeIndex++){
         hDriverType = driverTypes[driverTypeIndex];
         unsigned int deviceFlags = 0;
-#ifndef NDEBUG		
+#ifndef NDEBUG
                 // XXX: this is problematic in some environments.
-//		deviceFlags |= D3D11_CREATE_DEVICE_DEBUG;
+//                deviceFlags |= D3D11_CREATE_DEVICE_DEBUG;
 #endif
         hr = D3D11CreateDeviceAndSwapChain(NULL,
                                            hDriverType, NULL, deviceFlags, NULL, 0,
@@ -1552,6 +1752,14 @@ initD3D11(HWND hWnd) {
     g_pd3dDevice->CreateDepthStencilState(&depthStencilDesc, &g_pDepthStencilState);
     assert(g_pDepthStencilState);
 
+#ifdef PIPELINE_STATISTICS
+    // Create pipeline statistics query
+    D3D11_QUERY_DESC queryDesc;
+    ZeroMemory(&queryDesc, sizeof(D3D11_QUERY_DESC));
+    queryDesc.Query = D3D11_QUERY_PIPELINE_STATISTICS;
+    g_pd3dDevice->CreateQuery(&queryDesc, &g_pipelineStatsQuery);
+#endif // PIPELINE_STATISTICS
+
     return true;
 }
 
@@ -1694,6 +1902,23 @@ tokenize(std::string const & src) {
     return result;
 }
 
+//------------------------------------------------------------------------------
+void usage(const char *program) {
+    printf("Usage: %s [options] <color.ptx> [<displacement.ptx>] [occlusion.ptx>] "
+           "[specular.ptx] [pose.obj]...\n", program);
+    printf("Options:  -l level                : subdivision level\n");
+    printf("          -c count                : frame count until exit (for profiler)\n");
+    printf("          -d <diffseEnvMap.hdr>   : diffuse environment map for IBL\n");
+    printf("          -e <specularEnvMap.hdr> : specular environment map for IBL\n");
+    printf("          -s <shaderfile.glsl>    : custom shader file\n");
+    printf("          -y                      : Y-up model\n");
+    printf("          -m level                : max mimmap level (default=10)\n");
+    printf("          -x <ptex limit MB>      : ptex target memory size\n");
+    printf("          --disp <scale>          : Displacment scale\n");
+}
+
+//------------------------------------------------------------------------------
+
 int WINAPI
 WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPTSTR lpCmdLine, int nCmdShow) {
 
@@ -1735,6 +1960,7 @@ WinMain(HINSTANCE hInstance, HINSTANCE h
     const char *diffuseEnvironmentMap = NULL, *specularEnvironmentMap = NULL;
     const char *colorFilename = NULL, *displacementFilename = NULL,
         *occlusionFilename = NULL, *specularFilename = NULL;
+    int memLimit;
 
     for (int i = 0; i < (int)argv.size(); ++i) {
         if (strstr(argv[i].c_str(), ".obj"))
@@ -1747,10 +1973,14 @@ WinMain(HINSTANCE hInstance, HINSTANCE h
             diffuseEnvironmentMap = argv[++i].c_str();
         else if (argv[i] == "-e")
             specularEnvironmentMap = argv[++i].c_str();
+        else if (argv[i] == "-f")
+            g_fullscreen = true;
         else if (argv[i] == "-y")
             g_yup = true;
         else if (argv[i] == "-m")
             g_maxMipmapLevels = atoi(argv[++i].c_str());
+        else if (argv[i] == "-x")
+            memLimit = atoi(argv[++i].c_str());
         else if (argv[i] == "--disp")
             g_displacementScale = (float)atof(argv[++i].c_str());
         else if (colorFilename == NULL)
@@ -1772,7 +2002,7 @@ WinMain(HINSTANCE hInstance, HINSTANCE h
 
     g_ptexColorFilename = colorFilename;
     if (g_ptexColorFilename == NULL) {
-        printf("Usage: \n");
+        usage(argv[0].c_str());
         return 1;
     }
 
@@ -1781,13 +2011,98 @@ WinMain(HINSTANCE hInstance, HINSTANCE h
     createOsdMesh(g_level, g_kernel);
 
     // load ptex files
-    g_osdPTexImage = createPtex(colorFilename);
+    g_osdPTexImage = createPtex(colorFilename, memLimit);
     if (displacementFilename)
-        g_osdPTexDisplacement = createPtex(displacementFilename);
+        g_osdPTexDisplacement = createPtex(displacementFilename, memLimit);
     if (occlusionFilename)
-        g_osdPTexOcclusion = createPtex(occlusionFilename);
+        g_osdPTexOcclusion = createPtex(occlusionFilename, memLimit);
     if (specularFilename)
-        g_osdPTexSpecular = createPtex(specularFilename);
+        g_osdPTexSpecular = createPtex(specularFilename, memLimit);
+
+    g_ptexMemoryUsage =
+        (g_osdPTexImage ? g_osdPTexImage->GetMemoryUsage() : 0)
+        + (g_osdPTexDisplacement ? g_osdPTexDisplacement->GetMemoryUsage() : 0)
+        + (g_osdPTexOcclusion ? g_osdPTexOcclusion->GetMemoryUsage() : 0)
+        + (g_osdPTexSpecular ? g_osdPTexSpecular->GetMemoryUsage() : 0);
+
+    // load animation obj sequences (optional)
+    if (not animobjs.empty()) {
+        for (int i = 0; i < (int)animobjs.size(); ++i) {
+            std::ifstream ifs(animobjs[i].c_str());
+            if (ifs) {
+                std::stringstream ss;
+                ss << ifs.rdbuf();
+                ifs.close();
+
+                printf("Reading %s\r", animobjs[i].c_str());
+                std::string str = ss.str();
+                Shape *shape = Shape::parseObj(str.c_str(), kCatmark);
+
+                if (shape->verts.size() != g_positions.size()) {
+                    printf("Error: vertex count doesn't match.\n");
+                    goto end;
+                }
+
+                g_animPositions.push_back(shape->verts);
+                delete shape;
+            } else {
+                printf("Error in reading %s\n", animobjs[i].c_str());
+                goto end;
+            }
+        }
+        printf("\n");
+    }
+
+    // IBL textures
+    if (diffuseEnvironmentMap) {
+
+        g_diffuseEnvironmentMap =
+            createHDRTexture(g_pd3dDevice, diffuseEnvironmentMap);
+        assert(g_diffuseEnvironmentMap);
+
+        D3D11_SHADER_RESOURCE_VIEW_DESC srvDesc;
+        ZeroMemory(&srvDesc, sizeof(srvDesc));
+        srvDesc.Format = DXGI_FORMAT_R32G32B32A32_FLOAT;
+        srvDesc.ViewDimension = D3D11_SRV_DIMENSION_TEXTURE2D;
+        srvDesc.Texture2D.MostDetailedMip = 0;
+        srvDesc.Texture2D.MipLevels = 1;
+        g_pd3dDevice->CreateShaderResourceView(g_diffuseEnvironmentMap, &srvDesc, &g_diffuseEnvironmentSRV);
+        assert(g_diffuseEnvironmentSRV);
+    }
+
+    if (specularEnvironmentMap) {
+
+        g_specularEnvironmentMap =
+            createHDRTexture(g_pd3dDevice, specularEnvironmentMap);
+        assert(g_specularEnvironmentMap);
+
+        D3D11_SHADER_RESOURCE_VIEW_DESC srvDesc;
+        ZeroMemory(&srvDesc, sizeof(srvDesc));
+        srvDesc.Format = DXGI_FORMAT_R32G32B32A32_FLOAT;
+        srvDesc.ViewDimension = D3D11_SRV_DIMENSION_TEXTURE2D;
+        srvDesc.Texture2D.MostDetailedMip = 0;
+        srvDesc.Texture2D.MipLevels = 1;
+        g_pd3dDevice->CreateShaderResourceView(g_specularEnvironmentMap, &srvDesc, &g_specularEnvironmentSRV);
+        assert(g_specularEnvironmentSRV);
+    }
+    
+    if (g_diffuseEnvironmentMap || g_specularEnvironmentMap) {
+
+        // texture sampler
+        D3D11_SAMPLER_DESC samplerDesc;
+        ZeroMemory(&samplerDesc, sizeof(samplerDesc));
+        samplerDesc.Filter = D3D11_FILTER_MIN_MAG_LINEAR_MIP_POINT;
+        samplerDesc.AddressU = samplerDesc.AddressV = samplerDesc.AddressW = D3D11_TEXTURE_ADDRESS_WRAP;
+        samplerDesc.MaxAnisotropy = 0;
+        samplerDesc.ComparisonFunc = D3D11_COMPARISON_NEVER;
+        samplerDesc.MinLOD = 0;
+        samplerDesc.MaxLOD = D3D11_FLOAT32_MAX;
+        samplerDesc.BorderColor[0] = samplerDesc.BorderColor[1] = samplerDesc.BorderColor[2] = samplerDesc.BorderColor[3] = 0.0f;
+        g_pd3dDevice->CreateSamplerState(&samplerDesc, &g_iblSampler);
+
+        g_sky = new Sky(g_pd3dDevice, g_specularEnvironmentMap!=0 ?
+            g_specularEnvironmentMap : g_diffuseEnvironmentMap);
+    }
 
     initHUD();
 
diff -purN a/examples/dxPtexViewer/shader.hlsl b/examples/dxPtexViewer/shader.hlsl
--- a/examples/dxPtexViewer/shader.hlsl	2016-03-25 22:16:43.000000000 +0000
+++ b/examples/dxPtexViewer/shader.hlsl	2016-03-29 20:20:59.000000000 +0100
@@ -30,6 +30,7 @@ cbuffer Transform : register( b0 ) {
     float4x4 ModelViewMatrix;
     float4x4 ProjectionMatrix;
     float4x4 ModelViewProjectionMatrix;
+    float4x4 ModelViewInverseMatrix;
 };
 
 cbuffer Tessellation : register( b1 ) {
@@ -290,6 +291,31 @@ void gs_main( triangle OutputVertex inpu
 
 
 // ---------------------------------------------------------------------------
+//  IBL lighting
+// ---------------------------------------------------------------------------
+
+Texture2D diffuseEnvironmentMap : register(t12);
+Texture2D specularEnvironmentMap : register(t13);
+
+SamplerState iblSampler : register(s0);
+
+#define M_PI 3.14159265358
+
+float4
+gamma(float4 value, float g) {
+    return float4(pow(value.xyz, float3(g,g,g)), 1);
+}
+
+float4
+getEnvironmentHDR(Texture2D tx, SamplerState sm, float3 dir)
+{
+    dir = mul(ModelViewInverseMatrix, float4(dir, 0)).xyz;
+    float2 uv = float2((atan2(dir.x,dir.z)/M_PI+1)*0.5, (1-dir.y)*0.5);
+    return tx.Sample(sm, uv);
+}
+
+
+// ---------------------------------------------------------------------------
 //  Lighting
 // ---------------------------------------------------------------------------
 
@@ -559,8 +585,38 @@ ps_main(in OutputVertex input,
 #else
     float specular = 1.0;
 #endif
+
     // ------------ lighting ---------------
+#ifdef USE_IBL
+    // non-plausible BRDF
+    float4 a = float4(0, 0, 0, 1); //ambientColor;
+    float4 d = getEnvironmentHDR(diffuseEnvironmentMap, iblSampler, normal);
+
+    float3 eye = normalize(input.position.xyz - float3(0,0,0));
+    float3 r = reflect(eye, normal);
+    float4 s = getEnvironmentHDR(specularEnvironmentMap, iblSampler, r);
+
+    const float fresnelBias = 0.01;
+    const float fresnelScale = 1.0;
+    const float fresnelPower = 3.5;
+    float F = fresnelBias + fresnelScale * pow(1.0+dot(normal,eye), fresnelPower);
+
+    // Geometric attenuation term (
+    float NoV = dot(normal, -eye);
+    float alpha = 0.75 * 0.75; // roughness ^ 2
+    float k = alpha * 0.5;
+    float G = NoV/(NoV*(1-k)+k);
+
+    a *= (1-occ);
+    d *= (1-occ);
+    s *= min(specular, (1-occ)) * (F*G);
+
+    float4 Cf = (a+d)*texColor*(1-F)/M_PI + s;
+    //Cf = gamma(Cf, 2.2);
+
+#else
     float4 Cf = lighting(texColor, input.position.xyz, normal, occ);
+#endif
 
     // ------------ wireframe ---------------
     outColor = edgeColor(Cf, input.edgeDistance);
diff -purN a/examples/dxPtexViewer/sky.cpp b/examples/dxPtexViewer/sky.cpp
--- a/examples/dxPtexViewer/sky.cpp	1970-01-01 01:00:00.000000000 +0100
+++ b/examples/dxPtexViewer/sky.cpp	2016-03-29 20:20:59.000000000 +0100
@@ -0,0 +1,257 @@
+//
+//   Copyright 2013 Nvidia
+//
+//   Licensed under the Apache License, Version 2.0 (the "Apache License")
+//   with the following modification; you may not use this file except in
+//   compliance with the Apache License and the following modification to it:
+//   Section 6. Trademarks. is deleted and replaced with:
+//
+//   6. Trademarks. This License does not grant permission to use the trade
+//      names, trademarks, service marks, or product names of the Licensor
+//      and its affiliates, except as required to comply with Section 4(c) of
+//      the License and to reproduce the content of the NOTICE file.
+//
+//   You may obtain a copy of the Apache License at
+//
+//       http://www.apache.org/licenses/LICENSE-2.0
+//
+//   Unless required by applicable law or agreed to in writing, software
+//   distributed under the Apache License with the above modification is
+//   distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+//   KIND, either express or implied. See the Apache License for the specific
+//   language governing permissions and limitations under the Apache License.
+//
+
+
+#include "./sky.h"
+
+#include "../common/d3d11Utils.h"
+
+#include <cassert>
+#include <vector>
+
+static const char *g_skyShaderSource =
+#include "skyshader.gen.h"
+;
+
+#define SAFE_RELEASE(p) { if(p) { (p)->Release(); (p)=NULL; } }
+
+// shader constants
+__declspec(align(16)) struct CB_CONSTANTS {
+        float ModelViewMatrix[16];
+};
+
+
+Sky::Sky(ID3D11Device * device, ID3D11Texture2D * environmentMap) :
+    numIndices(0), 
+    vertexShader(0),
+    pixelShader(0),
+    shaderConstants(0),
+    texture(environmentMap), // we do not own this - we do not release it !
+    textureSRV(0),
+    textureSS(0),
+    inputLayout(0),
+    rasterizerState(0),
+    depthStencilState(0),
+    sphere(0),
+    sphereIndices(0) { 
+
+    initialize(device);
+}
+
+Sky::~Sky() {
+    SAFE_RELEASE(vertexShader);
+    SAFE_RELEASE(pixelShader);
+    SAFE_RELEASE(shaderConstants);
+    SAFE_RELEASE(inputLayout);
+    SAFE_RELEASE(rasterizerState);
+    SAFE_RELEASE(depthStencilState);
+    SAFE_RELEASE(textureSS);
+    SAFE_RELEASE(textureSRV);
+    SAFE_RELEASE(sphere);
+    SAFE_RELEASE(sphereIndices);
+}
+
+void
+Sky::initialize(ID3D11Device * device) {
+
+    // compile shaders
+    ID3DBlob * pVSBlob = D3D11Utils::CompileShader(g_skyShaderSource, "vs_main", "vs_5_0"),
+             * pPSBlob = D3D11Utils::CompileShader(g_skyShaderSource, "ps_main", "ps_5_0");
+    assert(pVSBlob && pPSBlob);
+
+    device->CreateVertexShader(pVSBlob->GetBufferPointer(),
+        pVSBlob->GetBufferSize(), NULL, &vertexShader);
+    assert(vertexShader);
+
+    device->CreatePixelShader(pPSBlob->GetBufferPointer(),
+        pPSBlob->GetBufferSize(), NULL, &pixelShader);
+    assert(pixelShader);
+
+    // VBO layout
+    D3D11_INPUT_ELEMENT_DESC inputElementDesc[] = {
+        { "POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 0, D3D11_INPUT_PER_VERTEX_DATA, 0 },
+        { "TEXCOORD", 0, DXGI_FORMAT_R32G32_FLOAT, 0, sizeof(float)*3, D3D11_INPUT_PER_VERTEX_DATA, 0 },
+    };
+    device->CreateInputLayout(inputElementDesc, ARRAYSIZE(inputElementDesc),
+        pVSBlob->GetBufferPointer(), pVSBlob->GetBufferSize(), &inputLayout);
+    assert(inputLayout);
+
+    // shader constants
+    D3D11_BUFFER_DESC cbDesc;
+    ZeroMemory(&cbDesc, sizeof(cbDesc));
+    cbDesc.Usage = D3D11_USAGE_DYNAMIC;
+    cbDesc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
+    cbDesc.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;
+    cbDesc.MiscFlags = 0;
+    cbDesc.ByteWidth = sizeof(CB_CONSTANTS);
+    device->CreateBuffer(&cbDesc, NULL, &shaderConstants);
+    assert(shaderConstants);
+
+    // texture SRV
+    assert(texture);
+    D3D11_SHADER_RESOURCE_VIEW_DESC srvDesc;
+    ZeroMemory(&srvDesc, sizeof(srvDesc));
+    srvDesc.Format = DXGI_FORMAT_R32G32B32A32_FLOAT;
+    srvDesc.ViewDimension = D3D11_SRV_DIMENSION_TEXTURE2D;
+    srvDesc.Texture2D.MostDetailedMip = 0;
+    srvDesc.Texture2D.MipLevels = 1;
+    device->CreateShaderResourceView(texture, &srvDesc, &textureSRV);
+    assert(textureSRV);
+
+    // texture sampler
+    D3D11_SAMPLER_DESC samplerDesc;
+    ZeroMemory(&samplerDesc, sizeof(samplerDesc));
+    samplerDesc.Filter = D3D11_FILTER_MIN_MAG_LINEAR_MIP_POINT;
+    samplerDesc.AddressU = samplerDesc.AddressV = samplerDesc.AddressW = D3D11_TEXTURE_ADDRESS_WRAP;
+    samplerDesc.MaxAnisotropy = 0;
+    samplerDesc.ComparisonFunc = D3D11_COMPARISON_NEVER;
+    samplerDesc.MinLOD = 0;
+    samplerDesc.MaxLOD = D3D11_FLOAT32_MAX;
+    samplerDesc.BorderColor[0] = samplerDesc.BorderColor[1] = samplerDesc.BorderColor[2] = samplerDesc.BorderColor[3] = 0.0f;
+    device->CreateSamplerState(&samplerDesc, &textureSS);
+
+    // depth stencil state
+    D3D11_DEPTH_STENCIL_DESC depthStencilDesc;
+    ZeroMemory(&depthStencilDesc, sizeof(depthStencilDesc));
+    depthStencilDesc.DepthEnable = true;
+    depthStencilDesc.DepthWriteMask = D3D11_DEPTH_WRITE_MASK_ZERO;
+    depthStencilDesc.DepthFunc = D3D11_COMPARISON_LESS_EQUAL;
+    depthStencilDesc.StencilEnable = false;
+    device->CreateDepthStencilState(&depthStencilDesc, &depthStencilState);
+
+    // rasterizer state
+    D3D11_RASTERIZER_DESC rasDesc;
+    rasDesc.FillMode = D3D11_FILL_SOLID;
+    rasDesc.CullMode = D3D11_CULL_NONE;
+    rasDesc.FrontCounterClockwise = FALSE;
+    rasDesc.DepthBias = 0;
+    rasDesc.DepthBiasClamp = 0;
+    rasDesc.DepthClipEnable = FALSE;
+    rasDesc.SlopeScaledDepthBias = 0.0f;
+    rasDesc.ScissorEnable = FALSE;
+    rasDesc.MultisampleEnable = FALSE;
+    rasDesc.AntialiasedLineEnable = FALSE;
+    device->CreateRasterizerState(&rasDesc, &rasterizerState);
+    assert(rasterizerState);
+
+    const int U_DIV = 20,
+              V_DIV = 20;
+
+    std::vector<float> vbo;
+    std::vector<int> indices;
+    for (int u = 0; u <= U_DIV; ++u) {
+        for (int v = 0; v < V_DIV; ++v) {
+            float s = float(2*M_PI*float(u)/U_DIV);
+            float t = float(M_PI*float(v)/(V_DIV-1));
+            vbo.push_back(-sin(t)*sin(s));
+            vbo.push_back(cos(t));
+            vbo.push_back(-sin(t)*cos(s));
+            vbo.push_back(u/float(U_DIV));
+            vbo.push_back(v/float(V_DIV));
+
+            if (v > 0 && u > 0) {
+                indices.push_back((u-1)*V_DIV+v-1);
+                indices.push_back(u*V_DIV+v-1);
+                indices.push_back((u-1)*V_DIV+v);
+                indices.push_back((u-1)*V_DIV+v);
+                indices.push_back(u*V_DIV+v-1);
+                indices.push_back(u*V_DIV+v);
+            }
+        }
+    }
+
+    D3D11_BUFFER_DESC bufferDesc;
+    D3D11_SUBRESOURCE_DATA subData;
+
+    // topology indices
+    ZeroMemory(&bufferDesc, sizeof(bufferDesc));
+    bufferDesc.ByteWidth = (int)indices.size() * sizeof(int);
+    bufferDesc.Usage = D3D11_USAGE_DEFAULT;
+    bufferDesc.BindFlags = D3D11_BIND_INDEX_BUFFER;
+    bufferDesc.CPUAccessFlags = 0;
+    bufferDesc.MiscFlags = 0;
+    bufferDesc.StructureByteStride = sizeof(int);
+
+    ZeroMemory(&subData, sizeof(subData));
+    subData.pSysMem = &indices[0];
+    subData.SysMemPitch = 0;
+    subData.SysMemSlicePitch = 0;
+    device->CreateBuffer(&bufferDesc, &subData, &sphereIndices);
+    assert(sphereIndices);
+
+    // VBO
+    ZeroMemory(&bufferDesc, sizeof(bufferDesc));
+    bufferDesc.ByteWidth = (int)vbo.size() * sizeof(float);
+    bufferDesc.Usage = D3D11_USAGE_DEFAULT;
+    bufferDesc.BindFlags = D3D11_BIND_VERTEX_BUFFER;
+    bufferDesc.CPUAccessFlags = 0;
+    bufferDesc.MiscFlags = 0;
+
+    ZeroMemory(&subData, sizeof(subData));
+    subData.pSysMem = &vbo[0];
+    device->CreateBuffer(&bufferDesc, &subData, &sphere);
+    assert(sphere);
+
+    numIndices = (int)indices.size();
+}
+
+void
+Sky::Draw(ID3D11DeviceContext * deviceContext, float const mvp[16]) {
+
+    if (vertexShader==0 || pixelShader==0 || shaderConstants==0) return;
+
+    if (texture==0 || textureSRV==0 || textureSS==0) return;
+
+    if (sphere==0 || sphereIndices==0) return;
+
+    // update shader constants
+    D3D11_MAPPED_SUBRESOURCE MappedResource;
+    deviceContext->Map(shaderConstants, 0, D3D11_MAP_WRITE_DISCARD, 0, &MappedResource);
+    CB_CONSTANTS* pData = (CB_CONSTANTS*)MappedResource.pData;
+
+    memcpy(pData->ModelViewMatrix, mvp, 16*sizeof(float));
+
+    deviceContext->Unmap(shaderConstants, 0);
+
+    // draw
+    deviceContext->RSSetState(rasterizerState);
+    deviceContext->OMSetDepthStencilState(depthStencilState, 1);
+
+    deviceContext->VSSetShader(vertexShader, NULL, 0);
+    deviceContext->VSSetConstantBuffers(0, 1, &shaderConstants);
+
+    deviceContext->PSSetShader(pixelShader, NULL, 0);
+    deviceContext->PSSetShaderResources(0, 1, &textureSRV);
+    deviceContext->PSSetSamplers(0, 1, &textureSS);
+
+    UINT hStrides = 5*sizeof(float);
+    UINT hOffsets = 0;
+    deviceContext->IASetVertexBuffers(0, 1, &sphere, &hStrides, &hOffsets);
+    deviceContext->IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
+    deviceContext->IASetInputLayout(inputLayout);
+
+    deviceContext->IASetIndexBuffer(sphereIndices, DXGI_FORMAT_R32_UINT, 0);
+
+    deviceContext->DrawIndexed(numIndices, 0, 0);
+}
diff -purN a/examples/dxPtexViewer/sky.h b/examples/dxPtexViewer/sky.h
--- a/examples/dxPtexViewer/sky.h	1970-01-01 01:00:00.000000000 +0100
+++ b/examples/dxPtexViewer/sky.h	2016-03-29 20:20:59.000000000 +0100
@@ -0,0 +1,65 @@
+//
+//   Copyright 2013 Nvidia
+//
+//   Licensed under the Apache License, Version 2.0 (the "Apache License")
+//   with the following modification; you may not use this file except in
+//   compliance with the Apache License and the following modification to it:
+//   Section 6. Trademarks. is deleted and replaced with:
+//
+//   6. Trademarks. This License does not grant permission to use the trade
+//      names, trademarks, service marks, or product names of the Licensor
+//      and its affiliates, except as required to comply with Section 4(c) of
+//      the License and to reproduce the content of the NOTICE file.
+//
+//   You may obtain a copy of the Apache License at
+//
+//       http://www.apache.org/licenses/LICENSE-2.0
+//
+//   Unless required by applicable law or agreed to in writing, software
+//   distributed under the Apache License with the above modification is
+//   distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+//   KIND, either express or implied. See the Apache License for the specific
+//   language governing permissions and limitations under the Apache License.
+//
+
+#include <D3D11.h>
+#include <D3Dcompiler.h>
+
+//
+// Draws an environment sphere centered on the camera w/ a texture
+//
+class Sky {
+
+public:
+
+    // Constructor (Sky does not own the texture asset)
+    Sky(ID3D11Device * device, ID3D11Texture2D * environmentMap);
+
+    ~Sky();
+
+    void Draw(ID3D11DeviceContext * deviceContext, float const mvp[16]);
+
+private:
+
+    void initialize(ID3D11Device * device);
+
+private:
+
+    int numIndices;
+
+    ID3D11VertexShader * vertexShader;
+    ID3D11PixelShader * pixelShader;
+    ID3D11Buffer * shaderConstants;
+
+    ID3D11InputLayout * inputLayout;
+    ID3D11RasterizerState * rasterizerState;
+    ID3D11DepthStencilState * depthStencilState;
+
+    ID3D11Texture2D * texture;
+    ID3D11ShaderResourceView * textureSRV;
+    ID3D11SamplerState * textureSS;
+
+    ID3D11Buffer * sphere;
+    ID3D11Buffer * sphereIndices;
+};
+
diff -purN a/examples/dxPtexViewer/skyshader.hlsl b/examples/dxPtexViewer/skyshader.hlsl
--- a/examples/dxPtexViewer/skyshader.hlsl	1970-01-01 01:00:00.000000000 +0100
+++ b/examples/dxPtexViewer/skyshader.hlsl	2016-03-29 20:20:59.000000000 +0100
@@ -0,0 +1,80 @@
+//
+//   Copyright 2013 Nvidia
+//
+//   Licensed under the Apache License, Version 2.0 (the "Apache License")
+//   with the following modification; you may not use this file except in
+//   compliance with the Apache License and the following modification to it:
+//   Section 6. Trademarks. is deleted and replaced with:
+//
+//   6. Trademarks. This License does not grant permission to use the trade
+//      names, trademarks, service marks, or product names of the Licensor
+//      and its affiliates, except as required to comply with Section 4(c) of
+//      the License and to reproduce the content of the NOTICE file.
+//
+//   You may obtain a copy of the Apache License at
+//
+//       http://www.apache.org/licenses/LICENSE-2.0
+//
+//   Unless required by applicable law or agreed to in writing, software
+//   distributed under the Apache License with the above modification is
+//   distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+//   KIND, either express or implied. See the Apache License for the specific
+//   language governing permissions and limitations under the Apache License.
+//
+
+struct VS_InputVertex {
+    float3 position : POSITION0;
+    float2 texCoord : TEXCOORD0;
+};
+
+struct VS_OutputVertex {
+    float4 position : SV_POSITION0;
+    float2 texCoord : TEXCOORD0;
+};
+
+cbuffer Transform : register( b0 ) {
+    float4x4 ModelViewMatrix;
+};
+
+//--------------------------------------------------------------
+// sky vertex shader
+//--------------------------------------------------------------
+
+
+void vs_main(in VS_InputVertex input,
+             out VS_OutputVertex output) {
+
+    output.position = mul(ModelViewMatrix, float4(input.position,1));
+    output.texCoord = input.texCoord;
+}
+
+//--------------------------------------------------------------
+// sky pixel shader
+//--------------------------------------------------------------
+
+struct PS_InputVertex {
+    float4 position : SV_POSITION0;
+    float2 texCoord : TEXCOORD0;
+};
+
+Texture2D tx : register(t0);
+
+SamplerState sm : register(s0);
+
+float4
+gamma(float4 value, float g) {
+    return float4(pow(value.xyz, float3(g,g,g)), 1);
+}
+
+
+float4
+ps_main(in PS_InputVertex input) : SV_Target {
+
+    float4 tex = tx.Sample(sm, input.texCoord.xy);
+
+    //float4 outColor = gamma(tex,0.4545);
+    float4 outColor = tex;
+
+    return outColor;
+}
+
diff -purN a/examples/glPtexViewer/CMakeLists.txt b/examples/glPtexViewer/CMakeLists.txt
--- a/examples/glPtexViewer/CMakeLists.txt	2016-03-25 22:16:43.000000000 +0000
+++ b/examples/glPtexViewer/CMakeLists.txt	2016-03-29 20:20:59.000000000 +0100
@@ -35,6 +35,7 @@ list(APPEND PLATFORM_LIBRARIES
     "${OPENGL_LIBRARY}"
     "${GLFW_LIBRARIES}"
     "${PTEX_LIBRARY}"
+    "${ZLIB_LIBRARY}"
 )
 
 include_directories(

